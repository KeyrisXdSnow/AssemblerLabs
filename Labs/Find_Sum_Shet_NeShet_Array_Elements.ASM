;; Входные данные : массив целочисленных элементов, length = 5
;; Необходимо отдельно найти сумму его четных и нечётных элементов
;; Результат: 1 число сумма четных, 2 число - нечётных

        org 100h

        mov di, MyArray ; в di помещаем ссылку на начало нашего массива
        mov bh,2        ; в bh помещаем 2 ( признак четности = деление на 2 )
        mov cl,5        ; array length = 5

Main:
        xor ax,ax       ; refresh ax
        mov al,[di]     ; в al помещаемч элемент массива в al ( изначально 1 элемент )

        div bh          ; целочисленное деление на bh, остаток сохраняется в ah после
        ;операции сам
        cmp ah,0        ; сравниваем с 0
         je .Shet       ; =0 прыгаем по адресу метки .Shet ( go to .Shet )
         jne .NEshet    ; != 0 перемещаемся по адресу метки .Neshet ( полное название
        ; метки Main.Neshet / .Метка значит что это метка "относится" к метки выше
        ; если за Main написать метку Neshet все будет ок

.Shet:
     mov bl,byte[di]    ; помещаем элемент массива преобразованный до размера byte в bl
     add [Sum_Shet],bl  ; к "переменной" хранящей сумму чётных элементов добавляем bl
     inc di             ; наращиваем di на 1
     loop Main          ; loop нижняя граница цикла. Говорим, что пока выполняется
     ; условие работы цикла возвращаемся на метку Main
     ; Синтаксис цикла :
     ; MetkaCicleBegin
     ;     ......
     ; loop MetkaCicleBegin ( по сути представляет собой цикл for, вспомогательная
     ; переменная у нас тут di как только di=0 произойдет выход из цикла)
     ; цикл можно сделать и без loop на основе условных переходов и сравнений, просто
     ; loop обьединяет 3 операции (dec вспомогательной переменной, сравнить ее на = 0
     ; если не равна прыгнуть на метку начала цикла, если равно само из цикла выйдет)
     ; в 1 инструкцию loop

     jmp Final  ; после завеешения цикла попадаем сюда и прыгаем на метку Final

.NEshet:

     mov bl,byte[di]  ; помещаем элемент массива преобразованный до размера byte в bl
     add [Sum_NEshet],bl  ; к "переменной" хранящей сумму чётных элементов добавляем bl
     inc di               ; наращиваем di на 1
     loop Main            ; прыгаем на Main если цикл все еще работает
     ; как только вышли из цикла следующей в адресном пространстве лежит метка Final
     ;(которая ниже ) значит после циклов попадаем а неё

Final:

        mov al, [Sum_Shet]      ; в al помещаем сумму четных

        add al,'0'              ; на экран консоли нам нужно вывести СТРОКУ, а значит
        ; если мы просто выведем содержимое al, мы выведем символ с значением кода = al.
        ; Поэтому добавляем значения кода символа '0' ( 48 вроде ) и по таблице символов
        ; как раз получаем нужный нам код символа

        mov ah,02       ; стандарт вывода на консоль. Всегда в ah помещаем 02.
        ; 02 это номер команды по талице команд. Номер команды можно записывать в любой
        ; с/c
        mov dl,al       ; в dl мувим то, что хотим вывести. Если размер больше размера al
        ;смотреть в документацию как пофиксить Ж) ( dx )
        int 21h         ; вызываем прерывание с номером 21h. Сложно коротко обьяснить что
        ;это такое. Но постараюсь. Ты говоришь процессору : брат, тебе пора остановиться.
        ; Процессор отвечает : да братишка ты прав. И прерывает свою работу. Потом он
        ; спрашивает : брат, а нахрена я остановился. А ты ему отвечаешь : вот я ж тебе
        ; прерывание с кодом выслал. Вот сегодня это 21h, ты это посмотри чё оно значит
        ; по таблице прерываний, выполни что это прерывание хочет,
        ; ну и топой дальше работать. А я почилю.
        ; Ну и процессор такой: ну чё, я ж уже прервался, сморит что нужно сделать с
        ; прерыванием 21h.Смотрит, сморит, видит 21h, работа с потоками ввода/вывода
        ; ( вроде бы, я уже точно не помню, может еще что-то охватывает). Смотрит что
        ; это прерывание он него хочет. Ага код команды 02, это у нас вывести на консоль
        ; данных хранящиеся в dl. НУ и собственно это он и делает. И поскольку это вам
        ; не дискретку прогуливать, ему необходимы в процессе обработки различные регистры.
        ; так что с вероятности в 60% после обработки прерываний значения регистров
        ; общего назначения поменяются. Да вроде даже не только их, но это уже совсем
        ; другая история.
        ;

        mov ah,02  ; алгоритм тот же, выводим пробел
        mov dl,' '
        int 21h

        mov al, [Sum_NEshet] ; чтобы вывести сумму нечётных, + код с сиволом 48 ( ака 0 ),
        add al,'0'           ; зачем описано выше


        mov ah,02           ; ну и собственно выводим Сумму нечетный чисел =)
        mov dl,al
        int 21h

        mov ah,08          ; так завершаются все проги на асике, почему так, сейчас не
        ; особо важно
        int 21h
        ret
        ;; ВАЖНЫЙ КОММЕНТАРИЙ. Вы не сможете вывести сумму больше 9. Так как сумму
        ;; необходимо преобразовать в строку = к каждому разряду прибавить 48.
        ;; Пример: сумма 4. 4+'0'='4'/ 4 + 48 = 52, а символ с кодом 52 = '4'
        ;;         сумма 11. 11+48=59. Код символа с 58 явно не равен 11. Тут даже
        ;; 0_0



MyArray db 1,2,2,3,4
Sum_Shet db 0
Sum_NEshet db 0