
org 100h



      mov ah,09h
      mov dx,text0
      int 21h


      mov ah,0ah
      mov dx,stroka ;
      int 21h      ; инструкцию прерывания = выполненияет все функции до неё

    ; Пункт 1. Сравнение указанной в задании длины ( в моем коде это 2<L<9, где L - длина строки)
      mov ah,[stroka+1] ; копируем в 8-битный регистр ah адрес байта длины, т.е длину строки ( сторка=массив, а в масивах адрес индекса=его расположение считается как 1индекс+смещение... в строке 1-ый байт отводится
      cmp ah,2   ; сравниваем регистр ah и число 2 = Меньше ли нижней границы                                                                                        под мах. возможную длину а 2-оц байт - под реальную длину строки)
        jl BadStroka  ; <= Условный переход по заданной метке. В нашем случаем переход по адресу метки  BadStroka, если меньше или равно (переходы есть в таблице условных переходов => для каждого условия они разные( их даже несколько гы))
      cmp ah,9   ; Если усё хорошо, переход не осуществляется.  сравниваем регистр ah и число 2 =Больше ли верхней границы
        jg BadStroka   ; >= Условный переход по адресу метки BadStroka.... Если усё хорошо, переход не осуществляется.

    ; Пункт 2. 2-ой и 3-ий элемент строки должны быть равны
      mov ah,[stroka+4] ; успамянаем, либо читаем, что я написала выше. Счет байтов идёт с байта длины => stroka+4 = 3 элемент строки. Поскольку мы задали, что 1 элемент сроки/массива в памяти лежит как один байт то 3 эл.=stroka+4
      mov bh,[stroka+3] ; копируем в 8-битный регистр bh 2 элемент строки.                                А если бы мы задали, что 1 элемент занимает в мапяти 2 байта то 3 элемент = stroka+(4*2)...Хотя я могу ошибатся ибо хз байт длины удваивается ли тоже.Комооон вы читает комент человека, который вчера 1, ладно 2 раз, ассемблер открыл ^_^
      cmp ah,bh ; Сравниваем два 8-битных регистра. Выбирать инструкции/операции/команды/ мона только с операндами одинаковой длины
       jne BadStroka  ; not =  Если не равно ( да, ты правильно догадалась/ся, я же знаю, что Ксюша это тебе кинет =) ) Условный переход по адресу метки BadStroka

    ; Пункт 3 1 эелмент строки должен быть цифрой ( 0..9 включительно)
      mov ah,[stroka+2] ; копируем в 8-битный регистр ah 1 элемент сроки
      cmp ah,47         ; cравниваем ah и 47, где 47 - код символа 0 ( можно писать '0', асик и так умеет )
     jl  BadStroka     ; если меньше на BadStroka
      cmp ah,58         ; cравниваем ah и 58, где 58 - код символа 9 ( можно писать '9', асик и так тоже умеет не поверишь )
     jg  BadStroka     ; если больше на адрес метки  BadStroka

    ; элемент S[dlina], где S - stroka, a dlina - длина строки
       mov ah,[stroka+1] ;  в регистр ah копируем длину строки ( лежит в 1 байте )
          cmp ah,'a'     ; сравниваем код элемента, лежащего в регистре ah, с кодом 'a'
     jl     GoodStroka    ; если меньше на BadStroka
         cmp ah,'z'      ; сравниваем код элемента, лежащего в регистре ah, с кодом 'z'
     jg     GoodStroka    ; если больше на адрес метки  BadStroka

; ЕСЛИ НИ РАЗУ МЫ НЕ ПРЫГНУЛИ НА АДРЕС МЕТКИ GoodStroka, МЫ НАКОНЕЦ ПОПАДАЕМ В АДРЕС МЕТКИ  GoodStroka ( КОТОРАЯ КАК И  BadStroka  ЯВЛЯЕТСЯ ПРОЦЕДУРОЙ )
   GoodStroka:
      ; Вывод поясняющего текста
          mov ah,09h   ; передаем инстукцию для вывода строки
          mov dx,goodtext
          int 21h
        ; Конец программы  < так оформляется конец программы
      mov ah, 08h        ; <
      int 21h            ; <
      ret                ; <


   BadStroka:
      ; Вывод поясняющего текста
          mov ah,09h   ; передаем инстукцию для вывода строки
          mov dx,badtext
          int 21h
        ; Конец программы
      mov ah, 08h
      int 21h
      ret

;---------------------------------------------------------------------------------------------------------------------- ^_^
;Метки

stroka db 10,0,10 dup("$")  ; строка в dos должна кончатся $ => инициал-ем сразу всю строку $. Вводить можем длина сроки-1 символов   db - деректива ( именно это значит, что 1 символ занимает 1 байт)
text0 db ' Enter stroky {  symbols }:  $'    ; поясняющий текст0                                                                    ; 10,0,10  10-кол-во символов,0-минимальный=первый заполняемый, 10-мах-ый=последний заполняемый
badtext db 'No                                                                            $ '                                       ; dup("$") - dup(...) - копировать в каждый индекс то, что в скобках ( у нас '$')
goodtext db 'Yes                                                                          $'
; ответ нахрена пробелы в метках выше. Поскольку мы в память ничего не храним/передаем на долго(т.е. не храним эти метки с помощью push ). Выведется первая строка(но мы её не страем, это надо писать в коде(очестка стека))
    ; Когда выведется 2 она посимвольно будет заменять каждый элемент в старой строке. А коли 2 строка меньше 1, то и остатки от первой останутся на экране консоли ( если непонятно, просто сотри пробелы, и посмотри что случилася :D)
